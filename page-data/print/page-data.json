{"componentChunkName":"component---gatsby-theme-mdx-deck-src-templates-deck-js","path":"/print","webpackCompilationHash":"80f287469f6ec8c3a5be","result":{"data":{"deck":{"id":"7383d09b-7d8a-506a-b6b4-4d5a8e9917b8","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar theme = github;\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  theme: theme,\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"A path to Recursion Schemes\"), mdx(\"p\", null, \"Grigory Pomadchin (\", mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://github.com/favicon.ico\",\n    \"alt\": null\n  })), \" @pomadchin)\"), mdx(\"p\", null, \"(GIS) Open Source Software Engineer @ Azavea\"), mdx(\"hr\", null), mdx(\"h5\", null, \"Azavea, a BCorporation\"), mdx(\"img\", {\n    \"src\": \"/img/azavea.png\",\n    \"alt\": null\n  }), mdx(\"img\", {\n    \"src\": \"/img/geotrellis.png\",\n    \"alt\": null\n  }), mdx(\"br\", null), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Azavea applies GIS knowledges for positive impact \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://www.azavea.com/\"\n  }), \"https://www.azavea.com/\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://github.com/locationtech/geotrellis\"\n  }), \"https://github.com/locationtech/geotrellis\"))), mdx(\"hr\", null), mdx(\"h3\", null, \"DSL - is a computer \", mdx(\"em\", {\n    parentName: \"h3\"\n  }, \"language\")), mdx(\"h3\", null, \"specialized to a particular application \", mdx(\"em\", {\n    parentName: \"h3\"\n  }, \"domain\")), mdx(\"hr\", null), mdx(\"h4\", null, \"A small exercise: defining our own DSL\"), mdx(\"hr\", null), mdx(CodeSurferColumns, {\n    mdxType: \"CodeSurferColumns\"\n  }, mdx(Step, {\n    title: \"Step 1: Domain (GEOSPATIAL)\",\n    mdxType: \"Step\"\n  }, mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Tile \\u2013 chip of a scene (Array\", \"[Byte]\", \")\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Extent \\u2013 bounding box of a tile\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Raster \\u2013 a tuple (Tile, Extent)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Catalog of rasters - a list of rasters\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Task\"), \": Query a catalog of rasters by extent intersection / coverage / etc\")), mdx(\"img\", {\n    \"src\": \"/img/tilepyramid.png\",\n    \"alt\": null\n  }))), mdx(\"hr\", null), mdx(CodeSurferColumns, {\n    mdxType: \"CodeSurferColumns\"\n  }, mdx(Step, {\n    title: \"Step 1: Domain (GEOSPATIAL)\",\n    mdxType: \"Step\"\n  }, mdx(\"img\", {\n    \"src\": \"/img/query-viz-mid.jpg\",\n    \"alt\": null\n  }))), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\",\n    \"metastring\": \"title=\\\"Step 2: Language\\\" subtitle=\\\"Helper types to understand the domain better\\\"\",\n    \"title\": \"\\\"Step\",\n    \"2:\": true,\n    \"Language\\\"\": true,\n    \"subtitle\": \"\\\"Helper\",\n    \"types\": true,\n    \"to\": true,\n    \"understand\": true,\n    \"the\": true,\n    \"domain\": true,\n    \"better\\\"\": true\n  }), \"case class Extent(xmin: Double, ymin: Double, xmax: Double, ymax: Double)\\ntype Tile = Array[Byte]\\ntype Raster = (Tile, Extent)\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\",\n    \"metastring\": \"title=\\\"Step 2: Language\\\" subtitle=\\\"The DSL itself\\\"\",\n    \"title\": \"\\\"Step\",\n    \"2:\": true,\n    \"Language\\\"\": true,\n    \"subtitle\": \"\\\"The\",\n    \"DSL\": true,\n    \"itself\\\"\": true\n  }), \"case class Extent(xmin: Double, ymin: Double, xmax: Double, ymax: Double)\\ntype Tile = Array[Byte]\\ntype Raster = (Tile, Extent)\\n\\nsealed trait Query\\ncase class And(l: Query, r: Query) extends Query\\ncase class Or(l: Query, r: Query) extends Query\\ncase class Intersects(extent: Extent) extends Query\\ncase class All() extends Query\\ncase class Empty() extends Query\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\",\n    \"metastring\": \"title=\\\"Step 2: Language\\\" subtitle=\\\"The usage example\\\"\",\n    \"title\": \"\\\"Step\",\n    \"2:\": true,\n    \"Language\\\"\": true,\n    \"subtitle\": \"\\\"The\",\n    \"usage\": true,\n    \"example\\\"\": true\n  }), \"case class Extent(xmin: Double, ymin: Double, xmax: Double, ymax: Double)\\ntype Tile = Array[Byte]\\ntype Raster = (Tile, Extent)\\n\\nsealed trait Query\\ncase class And(l: Query, r: Query) extends Query\\ncase class Or(l: Query, r: Query) extends Query\\ncase class Intersects(extent: Extent) extends Query\\ncase class All() extends Query\\ncase class Empty() extends Query\\n\\nOr(And(Intersects(extent1), Intersects(extent2)), Intersects(extent3))\\n// some beaty here\\n((intersects(extent1) and intersects(extent2)) or intersects(extent3))\\n\"))), mdx(\"hr\", null), mdx(CodeSurferColumns, {\n    mdxType: \"CodeSurferColumns\"\n  }, mdx(Step, {\n    title: \"Step 2: Language\",\n    subtitle: \"The real query example\",\n    mdxType: \"Step\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\"\n  }), \"Or(\\n  And(\\n    And(\\n      Intersects(Extent(-116.9,34.8,-113.8,36.9)),\\n      Intersects(Extent(-115.5,33.2,-111.7,35.6))\\n    ),\\n    Intersects(Extent(-115.5,39.2,-110.9,42.5))\\n  ),\\n  Intersects(Extent(-107.6,38.5,-102.6,42.1))\\n)\\n\")), mdx(\"img\", {\n    \"src\": \"/img/query-viz-mid.jpg\",\n    \"alt\": null\n  }))), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\",\n    \"metastring\": \"1:8 title=\\\"Step 3: Language Interpretation\\\"\",\n    \"1:8\": true,\n    \"title\": \"\\\"Step\",\n    \"3:\": true,\n    \"Language\": true,\n    \"Interpretation\\\"\": true\n  }), \"def evalString(q: Query): String = \\n  q match {\\n    case And(q1, q2)   => s\\\"(${evalString(q1)} and ${evalString(q2)})\\\"\\n    case Or(q1, q2)    => s\\\"(${evalString(q1)} or ${evalString(q2)})\\\"\\n    case Intersects(e) => s\\\"(intersects $e)\\\"\\n    case All()         => \\\"(all)\\\"\\n    case Empty()       => \\\"(empty)\\\"\\n  }\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\",\n    \"metastring\": \"1:11 title=\\\"Step 3: Language Interpretation\\\"\",\n    \"1:11\": true,\n    \"title\": \"\\\"Step\",\n    \"3:\": true,\n    \"Language\": true,\n    \"Interpretation\\\"\": true\n  }), \"def evalList(q: Query): List[Raster] => List[Raster] = \\n  q match {\\n    case And(q1, q2)   => list => \\n                       val left = evalList(q1)(list) \\n                       evalList(q2)(left)\\n    case Or(q1, q2)    => list => \\n                       evalList(q1)(list) ++ evalList(q2)(list)\\n    case Intersects(e) => _.filter(_.extent.intersects(e))\\n    case All()         => identity\\n    case Empty()       => _ => Nil\\n  }\\n\"))), mdx(\"hr\", null), mdx(CodeSurferColumns, {\n    themes: [github, nightOwl],\n    mdxType: \"CodeSurferColumns\"\n  }, mdx(Step, {\n    title: \"Language Interpretation\",\n    mdxType: \"Step\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\"\n  }), \"def evalString(q: Query): String = \\n  q match {\\n    case And(q1, q2)   => s\\\"(${evalString(q1)} and ${evalString(q2)})\\\"\\n    case Or(q1, q2)    => s\\\"(${evalString(q1)} or ${evalString(q2)})\\\"\\n    case Intersects(e) => s\\\"(intersects $e)\\\"\\n    case All()         => \\\"(all)\\\"\\n    case Empty()       => \\\"(empty)\\\"\\n  }\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\"\n  }), \"def evalList(q: Query): List[Raster] => List[Raster] = \\n  q match {\\n    case And(q1, q2)   => list => \\n                       val left = evalList(q1)(list) \\n                       evalList(q2)(left)\\n    case Or(q1, q2)    => list => \\n                       evalList(q1)(list) ++ evalList(q2)(list)\\n    case Intersects(e) => _.filter(_.extent.intersects(e))\\n    case All()         => identity\\n    case Empty()       => _ => Nil\\n  }\\n\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\",\n    \"metastring\": \"1[5:14],3[32:41,54:63],4[32:41,53:62]\",\n    \"1[5:14],3[32:41,54:63],4[32:41,53:62]\": true\n  }), \"def evalString(q: Query): String = \\n  q match {\\n    case And(q1, q2)   => s\\\"(${evalString(q1)} and ${evalString(q2)})\\\"\\n    case Or(q1, q2)    => s\\\"(${evalString(q1)} or ${evalString(q2)})\\\"\\n    case Intersects(e) => s\\\"(intersects $e)\\\"\\n    case All()         => \\\"(all)\\\"\\n    case Empty()       => \\\"(empty)\\\"\\n  }\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\",\n    \"metastring\": \"1[5:12],4[35:42],5[24:31],7[24:31,46:53]\",\n    \"1[5:12],4[35:42],5[24:31],7[24:31,46:53]\": true\n  }), \"def evalList(q: Query): List[Raster] => List[Raster] = \\n  q match {\\n    case And(q1, q2)   => list => \\n                       val left = evalList(q1)(list) \\n                       evalList(q2)(left)\\n    case Or(q1, q2)    => list => \\n                       evalList(q1)(list) ++ evalList(q2)(list)\\n    case Intersects(e) => _.filter(_.extent.intersects(e))\\n    case All()         => identity\\n    case Empty()       => _ => Nil\\n  }\\n\")))), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\",\n    \"metastring\": \"title=\\\"Generalization\\\"\",\n    \"title\": \"\\\"Generalization\\\"\"\n  }), \"def eval[A](f: Query => A)(q: Query): A = ???\\n// where \\nval f = q match {\\n  case And(q1, q2)   => ???\\n  case Or(q1, q2)    => ???\\n  case Intersects(e) => ???\\n  case All()         => ???\\n  case Empty()       => ???\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\",\n    \"metastring\": \"1,2[5:13] title=\\\"Generalization\\\"\",\n    \"1,2[5:13]\": true,\n    \"title\": \"\\\"Generalization\\\"\"\n  }), \"// is it a foldRight?\\ndef foldRight[A](f: Query => A)(q: Query): A = ???\\n\"))), mdx(\"hr\", null), mdx(\"h6\", null, \"Generalized functions to traverse through nested structures are called \", mdx(\"em\", {\n    parentName: \"h6\"\n  }, \"recursion schemes\"), \".\"), mdx(\"hr\", null), mdx(CodeSurferColumns, {\n    themes: [github, nightOwl],\n    mdxType: \"CodeSurferColumns\"\n  }, mdx(Step, {\n    title: \"Factor recursion out\",\n    mdxType: \"Step\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\"\n  }), \"sealed trait Query\\ncase class And(l: Query, r: Query) extends Query\\ncase class Or(l: Query, r: Query) extends Query\\ncase class Intersects(extent: Extent) extends Query\\ncase class All() extends Query\\ncase class Empty() extends Query\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\"\n  }), \"sealed trait QueryF[A]\\ncase class And[A](l: A, r: A) extends QueryF[A]\\ncase class Or[A](l: A, r: A) extends QueryF[A]\\ncase class Intersects[A](extent: Extent) extends QueryF[A]\\ncase class All[A]() extends QueryF[A]\\ncase class Empty[A]() extends QueryF[A]\\n\"))), mdx(Step, {\n    title: \"Factor recursion out\",\n    subtitle: \"The type parameter seems to mean anything, but it is not\",\n    mdxType: \"Step\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\"\n  }), \"sealed trait Query\\ncase class And(l: Query, r: Query) extends Query\\ncase class Or(l: Query, r: Query) extends Query\\ncase class Intersects(extent: Extent) extends Query\\ncase class All() extends Query\\ncase class Empty() extends Query\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\",\n    \"metastring\": \"1[21:21],2[16:16,22:22,28:28,46:46],3[15:15,21:21,27:27,45:45],4[23:23,57:57],5[16:16,36:36],6[18:18,38:38]\",\n    \"1[21:21],2[16:16,22:22,28:28,46:46],3[15:15,21:21,27:27,45:45],4[23:23,57:57],5[16:16,36:36],6[18:18,38:38]\": true\n  }), \"sealed trait QueryF[A]\\ncase class And[A](l: A, r: A) extends QueryF[A]\\ncase class Or[A](l: A, r: A) extends QueryF[A]\\ncase class Intersects[A](extent: Extent) extends QueryF[A]\\ncase class All[A]() extends QueryF[A]\\ncase class Empty[A]() extends QueryF[A]\\n\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\"\n  }), \"sealed trait Query\\ncase class And(l: Query, r: Query) extends Query\\ncase class Or(l: Query, r: Query) extends Query\\ncase class Intersects(extent: Extent) extends Query\\ncase class All() extends Query\\ncase class Empty() extends Query\\n\\nval query = \\n  Or(\\n    And(\\n      Intersects(extent1), \\n      Intersects(extent2)\\n    ), \\n    Intersects(extent3)\\n  )\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\"\n  }), \"sealed trait QueryF[A]\\ncase class And[A](l: A, r: A) extends QueryF[A]\\ncase class Or[A](l: A, r: A) extends QueryF[A]\\ncase class Intersects[A](extent: Extent) extends QueryF[A]\\ncase class All[A]() extends QueryF[A]\\ncase class Empty[A]() extends QueryF[A]\\n\\nval query = \\n  Or(\\n    And(\\n      Intersects(extent1), \\n      Intersects(extent2)\\n    ),\\n    Intersects(extent3)\\n  )\\n\"))), mdx(Step, {\n    title: \"A minor issue: type of expressions depends on the trees shape\",\n    mdxType: \"Step\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\",\n    \"metastring\": \"8[13:17],17[13:17],20[13:17]\",\n    \"8[13:17],17[13:17],20[13:17]\": true\n  }), \"sealed trait Query\\ncase class And(l: Query, r: Query) extends Query\\ncase class Or(l: Query, r: Query) extends Query\\ncase class Intersects(extent: Extent) extends Query\\ncase class All() extends Query\\ncase class Empty() extends Query\\n\\nval query1: Query = \\n  Or(\\n    And(\\n      Intersects(extent1), \\n      Intersects(extent2)\\n    ), \\n    Intersects(extent3)\\n  )\\n\\nval query2: Query = \\n  Intersects(extent1)\\n\\nval query3: Query =\\n  Or(\\n    And(\\n      Intersects(extent1), \\n      And(\\n        Intersects(extent2), \\n        Intersects(extent3))\\n    ), \\n    Or(\\n      Intersects(extent4), \\n      Intersects(extent5)\\n    )\\n  )\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\",\n    \"metastring\": \"8[12:48],17[12:27],20[12:61]\",\n    \"8[12:48],17[12:27],20[12:61]\": true\n  }), \"sealed trait QueryF[A]\\ncase class And[A](l: A, r: A) extends QueryF[A]\\ncase class Or[A](l: A, r: A) extends QueryF[A]\\ncase class Intersects[A](extent: Extent) extends QueryF[A]\\ncase class All[A]() extends QueryF[A]\\ncase class Empty[A]() extends QueryF[A]\\n\\nval query1: QueryF[QueryF[_ <: QueryF[Nothing]]] =\\n  Or(\\n    And(\\n      Intersects(extent1), \\n      Intersects(extent2)\\n    ), \\n    Intersects(extent3)\\n  )\\n\\nval query2: QueryF[Nothing] = \\n  Intersects(extent1)\\n\\nval query3: QueryF[QueryF[_ <: QueryF[_ <: QueryF[Nothing]]]] =\\n  Or(\\n    And(\\n      Intersects(extent1), \\n      And(\\n        Intersects(extent2), \\n        Intersects(extent3))\\n    ), \\n    Or(\\n      Intersects(extent4), \\n      Intersects(extent5)\\n    )\\n  )\\n\\n\")))), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-markup\",\n    \"metastring\": \"title=\\\"Fixing the type using the fixed point\\\" subtitle=\\\"This can be a bit hard to parse\\\"\",\n    \"title\": \"\\\"Fixing\",\n    \"the\": true,\n    \"type\": true,\n    \"using\": true,\n    \"fixed\": true,\n    \"point\\\"\": true,\n    \"subtitle\": \"\\\"This\",\n    \"can\": true,\n    \"be\": true,\n    \"a\": true,\n    \"bit\": true,\n    \"hard\": true,\n    \"to\": true,\n    \"parse\\\"\": true\n  }), \"Fixed point of a function f is such x, \\nthat f(x) == x == f(f(x)) == ...\\n\\nBringing that to the type level means \\nthat F[X] == X == F[F[X]]] == ...\\n\\nFix is a function that computes\\na fixed point for the input F[_],\\nsuch as\\n\\nFix[F] == F[Fix[F]] == F[F[Fix[F]]] == ...\\n\\n\"))), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\",\n    \"metastring\": \"subtitle=\\\"Not better\\\"\",\n    \"subtitle\": \"\\\"Not\",\n    \"better\\\"\": true\n  }), \"case class Fix[F[_]](unfix: F[Fix[F]])\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\",\n    \"metastring\": \"subtitle=\\\"That is what it actually means\\\"\",\n    \"subtitle\": \"\\\"That\",\n    \"is\": true,\n    \"what\": true,\n    \"it\": true,\n    \"actually\": true,\n    \"means\\\"\": true\n  }), \"case class Fix[F[_]](unfix: F[Fix[F]])\\n\\nval query1: Fix[QueryF] =\\n  Fix(Or(\\n    Fix(And(\\n      Fix(Intersects(extent1)),\\n      Fix(Intersects(extent2))\\n    )),\\n    Fix(Intersects(extent3))\\n  ))\\n\\nval query2: Fix[QueryF] =\\n  Fix(Intersects(extent1))\\n\\nval query3: Fix[QueryF] =\\n  Fix(Or(\\n    Fix(And(\\n      Fix(Intersects(extent1)),\\n      Fix(And(\\n        Fix(Intersects(extent2)),\\n        Fix(Intersects(extent3)))\\n      ))),\\n      Fix(Or(\\n        Fix(Intersects(extent4)),\\n        Fix(Intersects(extent5))\\n      ))\\n  ))\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\",\n    \"metastring\": \"1[12:14],3[13:23],12[13:23],15[13:23]\",\n    \"1[12:14],3[13:23],12[13:23],15[13:23]\": true\n  }), \"case class Fix[F[_]](unfix: F[Fix[F]])\\n\\nval query1: Fix[QueryF] =\\n  Fix(Or(\\n    Fix(And(\\n      Fix(Intersects(extent1)),\\n      Fix(Intersects(extent2))\\n    )),\\n    Fix(Intersects(extent3))\\n  ))\\n\\nval query2: Fix[QueryF] =\\n  Fix(Intersects(extent1))\\n\\nval query3: Fix[QueryF] =\\n  Fix(Or(\\n    Fix(And(\\n      Fix(Intersects(extent1)),\\n      Fix(And(\\n        Fix(Intersects(extent2)),\\n        Fix(Intersects(extent3)))\\n      ))),\\n      Fix(Or(\\n        Fix(Intersects(extent4)),\\n        Fix(Intersects(extent5))\\n      ))\\n  ))\\n\"))), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\",\n    \"metastring\": \"title=\\\"Back to the foldRight\\\"\",\n    \"title\": \"\\\"Back\",\n    \"to\": true,\n    \"the\": true,\n    \"foldRight\\\"\": true\n  }), \"def foldRight[A](f: Query => A)(q: Query): A = ???\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"2\": true,\n    \"className\": \"language-scala\",\n    \"metastring\": \"2 title=\\\"Back to the foldRight\\\"\",\n    \"title\": \"\\\"Back\",\n    \"to\": true,\n    \"the\": true,\n    \"foldRight\\\"\": true\n  }), \"def foldRight[A](f: Query => A)(q: Query): A = ???\\ndef foldRight[A](f: QueryF[A] => A)(q: QueryF[A]): A = ???\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"3\": true,\n    \"className\": \"language-scala\",\n    \"metastring\": \"3 title=\\\"Back to the foldRight\\\"\",\n    \"title\": \"\\\"Back\",\n    \"to\": true,\n    \"the\": true,\n    \"foldRight\\\"\": true\n  }), \"def foldRight[A](f: Query => A)(q: Query): A = ???\\ndef foldRight[A](f: QueryF[A] => A)(q: QueryF[A]): A = ???\\ndef foldRight[F[_], A](f: F[A] => A)(fix: Fix[F]): A = ???\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\",\n    \"metastring\": \"1[27:35],2 subtitle=\\\"F[A] => A is called Algebra\\\"\",\n    \"1[27:35],2\": true,\n    \"subtitle\": \"\\\"F[A]\",\n    \"\": \">\",\n    \"A\": true,\n    \"is\": true,\n    \"called\": true,\n    \"Algebra\\\"\": true\n  }), \"def foldRight[F[_], A](f: F[A] => A)(fix: Fix[F]): A = ???\\ntype Algebra[F[_], A] = F[A] => A\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\",\n    \"metastring\": \"1[27:35],2,3\",\n    \"1[27:35],2,3\": true\n  }), \"def foldRight[F[_], A](f: F[A] => A)(fix: Fix[F]): A = ???\\ntype Algebra[F[_], A] = F[A] => A\\ndef foldRight[F[_], A](algebra: Algebra[F, A])(fix: Fix[F]): A = ???\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\",\n    \"metastring\": \"subtitle=\\\"foldRight is called catamorphism\\\"\",\n    \"subtitle\": \"\\\"foldRight\",\n    \"is\": true,\n    \"called\": true,\n    \"catamorphism\\\"\": true\n  }), \"type Algebra[F[_], A] = F[A] => A\\ndef foldRight[F[_], A](algebra: Algebra[F, A])(fix: Fix[F]): A = ???\\ndef cata[F[_], A](algebra: Algebra[F, A])(fix: Fix[F]): A = ???\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\",\n    \"metastring\": \"3[15:17] subtitle=\\\"We'd like to walk the tree to apply the fold function to each node\\\"\",\n    \"3[15:17]\": true,\n    \"subtitle\": \"\\\"We'd\",\n    \"like\": true,\n    \"to\": true,\n    \"walk\": true,\n    \"the\": true,\n    \"tree\": true,\n    \"apply\": true,\n    \"fold\": true,\n    \"function\": true,\n    \"each\": true,\n    \"node\\\"\": true\n  }), \"type Algebra[F[_], A] = F[A] => A\\ndef cata[F[_], A](algebra: Algebra[F, A])(fix: Fix[F]): A = \\n  algebra(fix.map(fa => cata(algebra)(fa))) // it doesn't compile\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\",\n    \"metastring\": \"3[11:13] subtitle=\\\"Fix[F] != F[Fix[F]]?\\\"\",\n    \"3[11:13]\": true,\n    \"subtitle\": \"\\\"Fix[F]\",\n    \"!\": \"\",\n    \"F[Fix[F]]?\\\"\": true\n  }), \"type Algebra[F[_], A] = F[A] => A\\ndef cata[F[_], A](algebra: Algebra[F, A])(fix: Fix[F]): A = \\n  algebra(fix.map(fa => cata(algebra)(fa))) // it doesn't compile\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\",\n    \"metastring\": \"1,4,5\",\n    \"1,4,5\": true\n  }), \"case class Fix[F[_]](unfix: F[Fix[F]])\\ntype Algebra[F[_], A] = F[A] => A\\ndef cata[F[_], A](algebra: Algebra[F, A])(fix: Fix[F]): A = \\n  algebra(fix.unfix.map(fa => cata(algebra)(fa)))\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\",\n    \"metastring\": \"1:12 subtitle='The Functor instance defined for the QueryF'\",\n    \"1:12\": true,\n    \"subtitle\": \"'The\",\n    \"Functor\": true,\n    \"instance\": true,\n    \"defined\": true,\n    \"for\": true,\n    \"the\": true,\n    \"QueryF'\": true\n  }), \"implicit val queryFFunctor: Functor[QueryF] = new Functor[QueryF] {\\n  def map[A, B](fa: QueryF[A])(f: A => B): QueryF[B] = fa match {\\n    case And(l, r)     => And(f(l), f(r))\\n    case Or(l, r)      => Or(f(l), f(r))\\n    case Intersects(v) => Intersects[B](v)\\n    case Empty()       => Empty[B]()\\n    case All()         => All[B]()\\n  }\\n}\\n\\ndef cata[F[_]: Functor, A](algebra: Algebra[F, A])(fix: Fix[F]): A = \\n  algebra(fix.unfix.map(fa => cata(algebra)(fa)))\\n\"))), mdx(\"hr\", null), mdx(CodeSurferColumns, {\n    themes: [github, nightOwl],\n    mdxType: \"CodeSurferColumns\"\n  }, mdx(Step, {\n    title: \"Language Interpretation\",\n    mdxType: \"Step\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\"\n  }), \"def evalString(q: Query) = q match {\\n  case And(q1, q2)   => s\\\"(${evalString(q1)} and ${evalString(q2)})\\\"\\n  case Or(q1, q2)    => s\\\"(${evalString(q1)} or ${evalString(q2)})\\\"\\n  case Intersects(e) => s\\\"(intersects $e)\\\"\\n  case All()         => \\\"(all)\\\"\\n  case Empty()       => \\\"(empty)\\\"\\n}\\n\\ndef evalList(q: Query) = q match {\\n  case And(q1, q2)   => list => \\n                        val left = evalList(q1)(list) \\n                        evalList(q2)(left)\\n  case Or(q1, q2)    => list => \\n                        evalList(q1)(list) ++ evalList(q2)(list)\\n  case Intersects(e) => _.filter(_.extent.intersects(e))\\n  case All()         => identity\\n  case Empty()       => _ => Nil\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\"\n  }), \"\\nval algebraString: Algebra[QueryF, String] = {\\n  case And(q1, q2)   => s\\\"($q1 and $q2)\\\"\\n  case Or(q1, q2)    => s\\\"($q1 or $q2)\\\"\\n  case Intersects(e) => s\\\"(intersects $e)\\\"\\n  case All()         => \\\"(all)\\\"\\n  case Empty()       => \\\"(empty)\\\"\\n}\\n\\nval algebraList: Algebra[QueryF, List[Raster] => List[Raster]] = {\\n  case And(q1, q2)   => list => val left = q1(list); q2(left)\\n  case Or(q1, q2)    => list => q1(list) ++ q2(list)\\n  case Intersects(e) => _.filter(_.extent.intersects(e))\\n  case All()         => identity\\n  case Empty()       => _ => Nil\\n}\\n\\n\"))), mdx(Step, {\n    title: \"Language Interpretation\",\n    mdxType: \"Step\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\"\n  }), \"def evalString(q: Query) = q match {\\n  case And(q1, q2)   => s\\\"(${evalString(q1)} and ${evalString(q2)})\\\"\\n  case Or(q1, q2)    => s\\\"(${evalString(q1)} or ${evalString(q2)})\\\"\\n  case Intersects(e) => s\\\"(intersects $e)\\\"\\n  case All()         => \\\"(all)\\\"\\n  case Empty()       => \\\"(empty)\\\"\\n}\\n\\ndef evalList(q: Query) = q match {\\n  case And(q1, q2)   => list => \\n                        val left = evalList(q1)(list) \\n                        evalList(q2)(left)\\n  case Or(q1, q2)    => list => \\n                        evalList(q1)(list) ++ evalList(q2)(list)\\n  case Intersects(e) => _.filter(_.extent.intersects(e))\\n  case All()         => identity\\n  case Empty()       => _ => Nil\\n}\\n\\nval query: Query = \\n  Or(\\n    And(\\n      Intersects(extent1), \\n      Intersects(extent2)\\n    ),\\n    Intersects(extent3)\\n  )\\n\\nevalString(query) //> String\\nevalList(query) //> List[Raster] => List[Raster]\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\"\n  }), \"\\nval algebraString: Algebra[QueryF, String] = {\\n  case And(q1, q2)   => s\\\"($q1 and $q2)\\\"\\n  case Or(q1, q2)    => s\\\"($q1 or $q2)\\\"\\n  case Intersects(e) => s\\\"(intersects $e)\\\"\\n  case All()         => \\\"(all)\\\"\\n  case Empty()       => \\\"(empty)\\\"\\n}\\n\\nval algebraList: Algebra[QueryF, List[Raster] => List[Raster]] = {\\n  case And(q1, q2)   => list => val left = q1(list); q2(left)\\n  case Or(q1, q2)    => list => q1(list) ++ q2(list)\\n  case Intersects(e) => _.filter(_.extent.intersects(e))\\n  case All()         => identity\\n  case Empty()       => _ => Nil\\n}\\n\\nval query: Fix[QueryF] =\\n  Fix(Or(\\n    Fix(And(\\n      Fix(Intersects(extent1)),\\n      Fix(Intersects(extent2))\\n    )),\\n    Fix(Intersects(extent3))\\n  ))\\n\\ncata(algebraString)(query) //> String\\ncata(algebraList)(query) //> List[Raster] => List[Raster]\\n\\n\")))), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\",\n    \"metastring\": \"title=\\\"What about the unfold function?\\\" subtitle=\\\"When there is a mention of a fold, a question about the unfold may appear\\\"\",\n    \"title\": \"\\\"What\",\n    \"about\": true,\n    \"the\": true,\n    \"unfold\": true,\n    \"function?\\\"\": true,\n    \"subtitle\": \"\\\"When\",\n    \"there\": true,\n    \"is\": true,\n    \"a\": true,\n    \"mention\": true,\n    \"of\": true,\n    \"fold,\": true,\n    \"question\": true,\n    \"may\": true,\n    \"appear\\\"\": true\n  }), \"def foldRight[F[_], A](f: F[A] => A)(fix: Fix[F]): A = ???\\ndef unfold[F[_], A](f: A => F[A])(a: A): Fix[F] = ???\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\",\n    \"metastring\": \"1[24:32] subtitle=\\\"A => F[A] is called Coalgebra\\\"\",\n    \"1[24:32]\": true,\n    \"subtitle\": \"\\\"A\",\n    \"\": \">\",\n    \"F[A]\": true,\n    \"is\": true,\n    \"called\": true,\n    \"Coalgebra\\\"\": true\n  }), \"def unfold[F[_], A](f: A => F[A])(a: A): Fix[F] = ???\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\",\n    \"metastring\": \"subtitle=\\\"A => F[A] is called Coalgebra\\\"\",\n    \"subtitle\": \"\\\"A\",\n    \"\": \">\",\n    \"F[A]\": true,\n    \"is\": true,\n    \"called\": true,\n    \"Coalgebra\\\"\": true\n  }), \"type Coalgebra[F[_], A] = A => F[A]\\n\\ndef unfold[F[_]: Functor, A](coalgebra: Coalgebra[F, A])(a: A): Fix[F] =\\n  Fix(coalgebra(a).map(a => unfold(coalgebra)(a)))\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\",\n    \"metastring\": \"subtitle=\\\"unfold is called anamorphism\\\"\",\n    \"subtitle\": \"\\\"unfold\",\n    \"is\": true,\n    \"called\": true,\n    \"anamorphism\\\"\": true\n  }), \"type Coalgebra[F[_], A] = A => F[A]\\n\\ndef unfold[F[_]: Functor, A](coalgebra: Coalgebra[F, A])(a: A): Fix[F] =\\n  Fix(coalgebra(a).map(a => unfold(coalgebra)(a)))\\n\\ndef ana[F[_]: Functor, A](coalgebra: Coalgebra[F, A])(a: A): Fix[F] =\\n  Fix(coalgebra(a).map(a => ana(coalgebra)(a)))\\n\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\",\n    \"metastring\": \"title=\\\"A Coalgebra example\\\" subtitle=\\\"to build a QueryF expression from a given JSON tree\\\"\",\n    \"title\": \"\\\"A\",\n    \"Coalgebra\": true,\n    \"example\\\"\": true,\n    \"subtitle\": \"\\\"to\",\n    \"build\": true,\n    \"a\": true,\n    \"QueryF\": true,\n    \"expression\": true,\n    \"from\": true,\n    \"given\": true,\n    \"JSON\": true,\n    \"tree\\\"\": true\n  }), \"// Circe can derive it\\nval algebraJson: Algebra[QueryF, Json] = _.asJson\\n// unfold circe.Json into QueryF\\nval coalgebraJson: Coalgebra[QueryF, Json] = _.foldWith(new Json.Folder[QueryF[Json]] {\\n  // ...\\n  def onObject(value: JsonObject): QueryF[Json]  =\\n    value\\n      .asJson\\n      .as[QueryF[Json]]\\n      .getOrElse(Empty[Json]())\\n})\\n\\ndef asJson(query: Fix[QueryF]): Json  = cata(algebraJson)(query)\\ndef fromJson(json: Json): Fix[QueryF] = ana(coalgebraJson)(json)\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\",\n    \"metastring\": \"title=\\\"A Coalgebra example\\\" subtitle=\\\"to build a QueryF expression from a given JSON tree\\\"\",\n    \"title\": \"\\\"A\",\n    \"Coalgebra\": true,\n    \"example\\\"\": true,\n    \"subtitle\": \"\\\"to\",\n    \"build\": true,\n    \"a\": true,\n    \"QueryF\": true,\n    \"expression\": true,\n    \"from\": true,\n    \"given\": true,\n    \"JSON\": true,\n    \"tree\\\"\": true\n  }), \"def asJson(query: Fix[QueryF]): Json  = cata(algebraJson)(query)\\ndef fromJson(json: Json): Fix[QueryF] = ana(coalgebraJson)(json)\\n\\nval json: Json = asJson(\\n  Fix(Or(\\n    Fix(And(\\n      Fix(And(\\n        Fix(Intersects(Extent(-116.9, 34.8, -113.8, 36.9))),\\n        Fix(Intersects(Extent(-115.5, 33.2, -111.7, 35.6)))\\n      )),\\n      Fix(Intersects(Extent(-115.5, 39.2, -110.9, 42.5)))\\n    )),\\n    Fix(Intersects(Extent(-107.6, 38.5, -102.6, 42.1)))\\n  ))\\n)\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"{\\n    \\\"Or\\\" : {\\n        \\\"l\\\" : {\\n            \\\"And\\\" : {\\n                \\\"l\\\" : {\\n                    \\\"And\\\" : {\\n                        \\\"l\\\" : {\\n                            \\\"Intersects\\\" : {\\n                                \\\"extent\\\" : {\\n                                    \\\"xmin\\\" : -116.9,\\n                                    \\\"ymin\\\" : 34.8,\\n                                    \\\"xmax\\\" : -113.8,\\n                                    \\\"ymax\\\" : 36.9\\n                                }\\n                            }\\n                        },\\n                        \\\"r\\\" : {\\n                            \\\"Intersects\\\" : {\\n                                \\\"extent\\\" : {\\n                                    \\\"xmin\\\" : -115.5,\\n                                    \\\"ymin\\\" : 33.2,\\n                                    \\\"xmax\\\" : -111.7,\\n                                    \\\"ymax\\\" : 35.6\\n                                }\\n                            }\\n                        }\\n                    }\\n                },\\n                \\\"r\\\" : {\\n                    \\\"Intersects\\\" : {\\n                        \\\"extent\\\" : {\\n                            \\\"xmin\\\" : -115.5,\\n                            \\\"ymin\\\" : 39.2,\\n                            \\\"xmax\\\" : -110.9,\\n                            \\\"ymax\\\" : 42.5\\n                        }\\n                    }\\n                }\\n            }\\n        },\\n        \\\"r\\\" : {\\n            \\\"Intersects\\\" : {\\n                \\\"extent\\\" : {\\n                    \\\"xmin\\\" : -107.6,\\n                    \\\"ymin\\\" : 38.5,\\n                    \\\"xmax\\\" : -102.6,\\n                    \\\"ymax\\\" : 42.1\\n                }\\n            }\\n        }\\n    }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\"\n  }), \"fromJson(json)\\n\\n// Fix(Or(\\n//   Fix(And(\\n//     Fix(And(\\n//       Fix(Intersects(Extent(-116.9, 34.8, -113.8, 36.9))),\\n//       Fix(Intersects(Extent(-115.5, 33.2, -111.7, 35.6)))\\n//     )),\\n//     Fix(Intersects(Extent(-115.5, 39.2, -110.9, 42.5)))\\n//   )),\\n//   Fix(Intersects(Extent(-107.6, 38.5, -102.6, 42.1)))\\n// ))\\n\\n\"))), mdx(\"hr\", null), mdx(CodeSurferColumns, {\n    themes: [github, nightOwl],\n    mdxType: \"CodeSurferColumns\"\n  }, mdx(Step, {\n    title: \"Compose cata and ana!\",\n    subtitle: \"In a single step\",\n    mdxType: \"Step\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\"\n  }), \"val coalgebraJson: Coalgebra[QueryF, Json] = ???\\nval algebraList: Algebra[QueryF, List[Raster] => List[Raster]] = ???\\n\\nval query = ana(coalgebraJson)(json: Json)\\n// Fix(Or(\\n//   Fix(And(\\n//     Fix(And(\\n//       Fix(Intersects(Extent(-116.9, 34.8, -113.8, 36.9))),\\n//       Fix(Intersects(Extent(-115.5, 33.2, -111.7, 35.6)))\\n//     )),\\n//     Fix(Intersects(Extent(-115.5, 39.2, -110.9, 42.5)))\\n//   )),\\n//   Fix(Intersects(Extent(-107.6, 38.5, -102.6, 42.1)))\\n// ))\\n\\n//> List[Raster] => List[Raster]\\ncata(algebraList)(query)\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\"\n  }), \"def hylo[F[_]: Functor, A, B]\\n  (algebra: Algebra[F, B], coalgebra: Coalgebra[F, A])\\n  (a: A): B =\\n    algebra(coalgebra(a).map(hylo(a => algebra, coalgebra)(a)))\\n\\n//> List[Raster] => List[Raster]\\nhylo(algebraList, coalgebraJson)(json: Json)\\n\"))), mdx(Step, {\n    title: \"Compose cata and ana!\",\n    subtitle: \"In a single step\",\n    mdxType: \"Step\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\"\n  }), \"cata(algebraList)(query) //> List[Raster] => List[Raster]\\n\\n//> List[Raster] => List[Raster]\\ncata(algebraList)(ana(coalgebraJson)(json: Json))\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scala\"\n  }), \"def hylo[F[_]: Functor, A, B]\\n  (algebra: Algebra[F, B], coalgebra: Coalgebra[F, A])\\n  (a: A): B =\\n    algebra(coalgebra(a).map(hylo(a => algebra, coalgebra)(a)))\\n\\n//> List[Raster] => List[Raster]\\nhylo(algebraList, coalgebraJson)(json: Json)\\n\")))), mdx(\"hr\", null), mdx(\"h3\", null, \"Benefits?\"), mdx(\"hr\", null), mdx(\"img\", {\n    \"src\": \"https://github.com/precog/matryoshka/raw/master/resources/recursion-schemes.png\",\n    \"alt\": null\n  }), mdx(\"hr\", null), mdx(\"h3\", null, \"Problems\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The barrier to entry\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Fix type in all expression signatures\")), mdx(\"hr\", null), mdx(\"h3\", null, \"Summary\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Recursion schemes are generalized functions to traverse through nested structures\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It is not a mystery, it is a powerfull tool that helps to work with nested data structures\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"There is more than a single way to traverse over the nested structure\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The barrier to entry is pretty high (unknown words and unknown types can be a problem)\")), mdx(\"hr\", null), mdx(\"h4\", null, \"Links:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://github.com/pomadchin/path-to-recschemes\"\n  }), \"https://github.com/pomadchin/path-to-recschemes\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://github.com/higherkindness/droste\"\n  }), \"https://github.com/higherkindness/droste\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://www.47deg.com/blog/recursion-schemes-introduction\"\n  }), \"https://www.47deg.com/blog/recursion-schemes-introduction\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"GitHub: @pomadchin \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Twitter: @daunnc\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Email: gr.pomadchin \", \"[at]\", \" gmail.com\")), mdx(\"h4\", null, \"Thanks!\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"7383d09b-7d8a-506a-b6b4-4d5a8e9917b8","slug":"","title":"A path to Recursion Schemes"}}}